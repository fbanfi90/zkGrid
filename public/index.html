<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width,initial-scale=1'>
    <title>zkGrid</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <style>
      html,body {
        height: 100%;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #222
      }
      canvas {
        max-width: 100%;
        max-height: 100%;
        display: block
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.7);
        display: none;
        z-index: 5;
      }
      #spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 128px;
        height: 128px;
        margin: -80px 0 0 -80px;
        border: 16px solid rgba(255,255,255,0.2);
        border-top: 16px solid #fff;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        display: none;
        z-index: 10;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      #qrcode {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        padding: 8px;
        border-radius: 8px;
        display: none;
        z-index: 15;
      }
      #qrcode.transparent {
        background: transparent;
        padding: 0;
        border-radius: 0;
      }
      #infoOverlay a {
        color: #aaddff;
        text-decoration: none;
        transition: color 0.15s ease-in-out;
      }
      #infoOverlay a:hover {
        color: #cce8ff;
      }
    </style>
  </head>
  <body>
    <div id="mainflex" style="display:flex;flex-direction:column;width:100vw;">
      <div id="toggleRow" style="display:none;align-items:center;justify-content:center;">
      <span style="color:#fff;font-size:1.1em;font-family:'Inter','Segoe UI','Roboto','Helvetica Neue',Arial,sans-serif;font-weight:600;">Solve</span>
        <label id="toggleSwitch" style="position:relative;display:inline-block;width:48px;height:24px;margin:0 16px;">
          <input id="toggleInput" type="checkbox" style="opacity:0;width:0;height:0;" checked>
          <span id="toggleBg" style="position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#444;border-radius:24px;transition:.2s;"></span>
          <span id="toggleKnob" style="position:absolute;top:2px;left:2px;width:20px;height:20px;background:#4caf50;border-radius:50%;transition:.2s;"></span>
        </label>
        <span style="color:#fff;font-size:1.1em;font-family:'Inter','Segoe UI','Roboto','Helvetica Neue',Arial,sans-serif;font-weight:600;">Verify</span>
      </div>
      <div id="gridRow" style="display:flex;align-items:center;justify-content:center;min-height:0;">
        <div id="gridbox" style="position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;">
          <canvas id='grid'></canvas>
          <video id="cameraStream" autoplay playsinline style="display:none;width:100%;height:100%;object-fit:cover;border:2px solid #fff;border-radius:8px;"></video>
          <div id='qrcode' style="width:92%;height:92%"></div>
        </div>
        <div id="infoOverlay" style="
          position:absolute;
          top:50%;
          left:50%;
          transform:translate(-50%,-50%);
          width:100%;
          height:100%;
          aspect-ratio:1/1;
          border-radius:8px;
          color:#fff;
          font-family:Helvetica,Arial,sans-serif;
          font-size:1rem;
          text-align:justify;
          line-height:1.5;
          padding:1.2em;
          display:none;
          z-index:20;
          cursor:pointer;
          box-sizing:border-box;
          overflow:auto;
        ">
          This puzzle game uses <a href="https://en.wikipedia.org/wiki/ZkSNARK">zk-SNARKs</a> to enable you to prove in <a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof">zero-knowledge</a> that you found the empty cell in a dotted grid, that is, without revealing its location. The proof is generated with <a href="https://docs.circom.io/">Circom</a> and <a href="https://github.com/iden3/snarkjs">snarkjs</a> using the <a href="https://eprint.iacr.org/2016/260">Groth16</a> proving system and is displayed as a QR code. Open the app on another device and select <b>Verify</b> to validate QR proofs. Zero-knowledge guarantees that the data in the QR code contains no information about the empty cell location.
          Get the code at:
          <br />
          <br />
          <p style="text-align:center;margin:0;">
            <a href="https://github.com/fbanfi90/zkGrid">github.com/fbanfi90/zkGrid</a>.
          </p>
          <br />
          Copyright (c) 2025 Fabio Banfi (<a href="https://fabiobanfi.com">fabiobanfi.com</a>).
        </div>
      </div>
      <div id="checkboxRow" style="display:none;align-items:center;justify-content:center;">
        <div style="background:#333;padding:8px 12px;border-radius:10px;display:flex;align-items:center;gap:10px;color:#fff;font-size:1.1em;font-family:'Inter','Segoe UI','Roboto','Helvetica Neue',Arial,sans-serif;">
          <input type="checkbox" id="qrProofCheckbox" checked style="width:20px;height:20px;accent-color:#4caf50;">
          <label for="qrProofCheckbox" style="cursor:pointer;user-select:none;font-weight:400;">Generate ZK Proof</label>
          <button id="infoButton" title="About" style="
            background:#555;
            color:#fff;
            border:none;
            border-radius:50%;
            width:22px;
            height:22px;
            font-weight:700;
            font-family:serif;
            font-style:italic;
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            line-height:1;
          ">i</button>
        </div>
      </div>
    </div>
    <div id='overlay'></div>
    <div id='spinner'></div>
    <script src='https://cdn.jsdelivr.net/npm/snarkjs@0.7.5/build/snarkjs.min.js'></script>
    <script src='https://unpkg.com/qr-code-styling@latest/lib/qr-code-styling.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script>
    (() => {
      // Dynamically set mainflex height for mobile viewport consistency
      function setMainflexHeight() {
        document.getElementById('mainflex').style.height = window.innerHeight + 'px';
      }
      setMainflexHeight();
      window.addEventListener('resize', setMainflexHeight);

      // Toggle switch visual logic
      const toggleInput = document.getElementById('toggleInput');
      const toggleKnob = document.getElementById('toggleKnob');
      if (toggleInput && toggleKnob) {
        toggleInput.addEventListener('change', async () => {
          const gridRow = document.getElementById('gridRow');
          const checkboxRow = document.getElementById('checkboxRow');
          const camera = document.getElementById('cameraStream');
          const canvas = document.getElementById('grid');
          const qrcode = document.getElementById("qrcode");
          
          qrcode.innerHTML = '';
          qrcode.style.display = 'none';
          
          toggleInput.disabled = true;
          toggleKnob.style.background = '#f44336';
          
          // Solve mode
          if (toggleInput.checked) {
            try {
              if (camera.srcObject) {
                camera.srcObject.getTracks().forEach(t => t.stop());
                camera.srcObject = null;
              }
              gridRow.style.display = 'flex';
              checkboxRow.style.display = 'flex';
              canvas.style.display = 'block';
              camera.style.display = 'none';
              toggleKnob.style.left = '2px';
            } finally {
              // Unlock and mark ready (green)
              toggleKnob.style.background = '#4caf50';
              toggleInput.disabled = false;
            }

          // Verify mode
          } else {
            gridRow.style.display = 'flex';
            checkboxRow.style.display = 'none';
            canvas.style.display = 'none';
            camera.style.display = 'block';
            toggleKnob.style.left = '26px';
            try {
              //const stream = await navigator.mediaDevices.getUserMedia({ video: true });
              let stream;
              try {
                stream = await navigator.mediaDevices.getUserMedia({
                  video: { facingMode: { exact: "environment" } }
                });
              } catch {
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
              }
              camera.srcObject = stream;

              const scanCanvas = document.createElement('canvas');
              const scanCtx = scanCanvas.getContext('2d');
              let scanningActive = true;

              async function verifyProofFromQR(data) {
                try {
                  const proof = JSON.parse(data);
                  const public = [];
                  const vkey = await vkeyPromise;
                  const valid = await snarkjs.groth16.verify(vkey, public, proof);
                  showVerifyResult(valid);
                } catch (e) {
                  console.error(e);
                  showVerifyResult(false);
                }
              }

              function showVerifyResult(valid) {
                scanningActive = false;
                const qrcode = document.getElementById('qrcode');
                qrcode.innerHTML = '';
                qrcode.style.display = 'block';
                qrcode.classList.add('transparent');
                const canvas = document.createElement('canvas');
                canvas.style.position = 'absolute';
                canvas.style.top = '50%';
                canvas.style.left = '50%';
                canvas.style.transform = 'translate(-50%, -50%)';
                canvas.width = 300;
                canvas.height = 300;
                const ctx = canvas.getContext('2d');
                ctx.beginPath();
                ctx.arc(150, 150, 120, 0, Math.PI * 2);
                ctx.fillStyle = valid ? '#4caf50' : '#f44336';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 32;
                ctx.beginPath();
                if (valid) {
                  ctx.moveTo(100, 150);
                  ctx.lineTo(140, 190);
                  ctx.lineTo(200, 110);
                } else {
                  ctx.moveTo(90, 90);
                  ctx.lineTo(210, 210);
                  ctx.moveTo(210, 90);
                  ctx.lineTo(90, 210);
                }
                ctx.stroke();
                qrcode.appendChild(canvas);

                // allow click to resume scanning
                qrcode.onclick = () => {
                  qrcode.innerHTML = '';
                  qrcode.style.display = 'none';
                  scanningActive = true;
                  requestAnimationFrame(scanLoop);
                };
              }

              function scanLoop() {
                if (!scanningActive || !camera.srcObject) return;
                scanCanvas.width = camera.videoWidth;
                scanCanvas.height = camera.videoHeight;
                scanCtx.drawImage(camera, 0, 0, scanCanvas.width, scanCanvas.height);
                const imageData = scanCtx.getImageData(0, 0, scanCanvas.width, scanCanvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                if (code) verifyProofFromQR(code.data);
                else requestAnimationFrame(scanLoop);
              }

              camera.addEventListener('playing', () => {
                scanningActive = true;
                requestAnimationFrame(scanLoop);
              }, { once: true });

              toggleKnob.style.background = '#2196f3';  // blue = ready/verify
            } catch (err) {
              console.error('Camera access failed:', err);
              toggleKnob.style.background = '#f44336';
            } finally {
              toggleInput.disabled = false;
            }
          }
        });
        // Set initial position
        if (toggleInput.checked) {
          toggleKnob.style.left = '2px';
          toggleKnob.style.background = '#4caf50';
        } else {
          toggleKnob.style.left = '26px';
          toggleKnob.style.background = '#2196f3';
        }
      }
      const canvas = document.getElementById('grid');
      const overlay = document.getElementById('overlay');
      const spinner = document.getElementById('spinner');
      const qrcode = document.getElementById('qrcode');
      const ctx = canvas.getContext('2d');

      const wasmPromise = fetch('lsbcheck.wasm').then(r => r.arrayBuffer());
      const zkeyPromise = fetch('lsbcheck.zkey').then(r => r.arrayBuffer());
      const vkeyPromise = fetch('vkey.json').then(r => r.json());
      
      let preloadedImageUrl = null;
      const imagePromise = fetch('zkGrid.png')
        .then(r => { if (!r.ok) throw new Error('image fetch failed'); return r.blob(); })
        .then(blob => {
          const url = URL.createObjectURL(blob);
          // warm-decode the image so drawing later is faster
          const img = new Image();
          img.src = url;
          preloadedImageUrl = url;
          return { url, img, blob };
        })
        .catch(() => null);
      // revoke the object URL when the page unloads to free memory
      window.addEventListener('beforeunload', () => {
        if (preloadedImageUrl) URL.revokeObjectURL(preloadedImageUrl);
      });

      const M = 16;
      const N = 16;
      const BORDER = 1;
      const DOT_DIAMETER_RATIO = 0.12;
      
      let cssSide;
      let cell;
      let dots = [];
      let overlays = {};
      let isReloading = false;
      let seed = null;
      let data = null;

      async function fetchData() {
        // await new Promise(resolve => setTimeout(resolve, 2000));
        try {
          const res = await fetch('/api/data');
          const json = await res.json();
          seed = json.seed;
          data = json.data;
          // Show toggle and checkbox rows after data is fetched
          document.getElementById('toggleRow').style.display = 'flex';
          document.getElementById('checkboxRow').style.display = 'flex';
        } catch (e) {
          console.error('Failed to fetch data:', e);
        }
      }

      async function generateProof(i, j) {
        const wasm = await wasmPromise;
        const zkey = await zkeyPromise;
        const inputs = { s: seed.toString(), i, j };
        const { proof } = await snarkjs.groth16.fullProve(
          inputs,
          new Uint8Array(wasm),
          new Uint8Array(zkey)
        );
        return proof;
      }

      async function showQRCode(obj) {
        qrcode.innerHTML = '';
        qrcode.style.display = 'block';
        qrcode.classList.remove('transparent');
        
        // Use the preloaded object URL (fast). If preloading failed, fall back to the static path.
        const imgData = preloadedImageUrl || (await imagePromise)?.url || '/zkGrid.png';
        
        new QRCodeStyling({
          type: 'canvas',
          shape: 'square',
          width: 1024,
          height: 1024,
          data: JSON.stringify(obj),
          margin: 0,
          qrOptions: { typeNumber: '0', mode: 'Byte', errorCorrectionLevel: 'L' },
          imageOptions: { saveAsBlob: true, hideBackgroundDots: true, imageSize: 1, margin: 0 },
          dotsOptions: { type: 'dots', color: '#000000', roundSize: true },
          backgroundOptions: { round: 0, color: '#ffffff', gradient: null },
          image: imgData,
          cornersSquareOptions: { type: 'extra-rounded', color: '#000000' },
          cornersDotOptions: { type: 'dot', color: '#000000' }
        }).append(qrcode);
      }
      
      function showError() {
        qrcode.innerHTML = '';
        qrcode.style.display = 'block';
        qrcode.classList.add('transparent');
        const errorCanvas = document.createElement('canvas');
        errorCanvas.width = 300;
        errorCanvas.height = 300;
        const ecx = errorCanvas.getContext('2d');
        ecx.beginPath();
        ecx.arc(150, 150, 120, 0, Math.PI * 2);
        ecx.fillStyle = '#f44336';
        ecx.fill();
        ecx.strokeStyle = '#fff';
        ecx.lineWidth = 32;
        ecx.beginPath();
        ecx.moveTo(90, 90);
        ecx.lineTo(210, 210);
        ecx.moveTo(210, 90);
        ecx.lineTo(90, 210);
        ecx.stroke();
        qrcode.appendChild(errorCanvas);
      }

      qrcode.addEventListener('click', async () => {
        overlay.style.display = 'block';
        qrcode.style.display = 'none';
        qrcode.innerHTML = '';
        spinner.style.display = 'block';
        if (window.dataPromise && window.dataPromise.then) {
          await window.dataPromise;
        }
        draw();
        isReloading = false;
        spinner.style.display = 'none';
        overlay.style.display = 'none';
      });

      function draw() {
        const dpr = window.devicePixelRatio || 1;
        let vw = window.innerWidth;
        let vh = window.innerHeight;
        let margin = 8;
        let isMobile = vh > vw;
        let gridSize, topH, bottomH;
        if (isMobile) {
          gridSize = vw - 2 * margin;
          let sideSpace = (vh - gridSize) / 2;
          topH = bottomH = sideSpace;
        } else {
          topH = bottomH = 64;
          gridSize = Math.min(vw - 2 * margin, vh - 2 * topH - 2 * margin);
        }
        // Set heights for top/bottom rows
        document.getElementById('toggleRow').style.height = topH + 'px';
        document.getElementById('checkboxRow').style.height = bottomH + 'px';
        // Set gridbox to exact square size
        const gridbox = document.getElementById('gridbox');
        gridbox.style.width = gridSize + 'px';
        gridbox.style.height = gridSize + 'px';
        canvas.style.width = gridSize + 'px';
        canvas.style.height = gridSize + 'px';
        canvas.width = gridSize * dpr;
        canvas.height = gridSize * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        cssSide = gridSize;
        cell = gridSize / M;
        generateDots();
        renderGrid();
      }

      function generateDots() {
        dots = [];
        if (!data) return;
        for (const item of data) {
          if (item.x === 0 && item.y === 0) {
            dots.push(null);
            continue;
          }
          const offsetX = ((item.x + 0.5) / N) * (cell - 8) + 4;
          const offsetY = ((item.y + 0.5) / N) * (cell - 8) + 4;
          const cx = item.j * cell + offsetX;
          const cy = item.i * cell + offsetY;
          dots.push({ cx, cy });
        }
      }

      function renderGrid() {
        ctx.clearRect(0, 0, cssSide, cssSide);
        const halfB = BORDER / 2;

        // Grid lines
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = BORDER;
        ctx.beginPath();
        for (let k = 0; k <= M; k++) {
          const pos = k * cell;
          ctx.moveTo(pos, 0); ctx.lineTo(pos, cssSide);
          ctx.moveTo(0, pos); ctx.lineTo(cssSide, pos);
        }
        ctx.stroke();
        ctx.strokeRect(halfB, halfB, cssSide - BORDER, cssSide - BORDER);

        // Draw dots (diameter = DOT_DIAMETER_RATIO * cell)
        ctx.fillStyle = '#fff';
        const dotRadius = (cell * DOT_DIAMETER_RATIO) / 2;
        dots.forEach(d => {
          if (!d) return;
          ctx.beginPath();
          ctx.arc(d.cx, d.cy, dotRadius, 0, Math.PI * 2);
          ctx.fill();
        });

        // Draw overlays
        for (const key in overlays) {
          const k = parseInt(key, 10);
          const i = Math.floor(k / M);
          const j = k % M;
          ctx.fillStyle = overlays[k].color;
          ctx.fillRect(j * cell, i * cell, cell, cell);
        }
      }

      canvas.addEventListener('click', async e => {
        if (isReloading) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const i = Math.floor(y / cell);
        const j = Math.floor(x / cell);
        const k = i * M + j;

        // Always get the current checkbox reference
        const qrProofCheckbox = document.getElementById('qrProofCheckbox');

        // Regular cell
        if (dots[k] !== null) {
          overlays[k] = { color: 'rgba(255,0,0,0.5)' };
          renderGrid();

          setTimeout(() => {
            delete overlays[k];
            renderGrid();
          }, 1000);

        // Empty cell
        } else {
          isReloading = true;

          overlays[k] = { color: 'rgba(0,255,0,0.5)' };
          renderGrid();
          spinner.style.display = 'block';
          overlay.style.display = 'block';

          setTimeout(() => {
            overlays = {};
            renderGrid();
          }, 500);

          window.dataPromise = fetchData();

          if (qrProofCheckbox && qrProofCheckbox.checked) {
            try {
              const proof = await generateProof(i, j);
              spinner.style.display = 'none';
              showQRCode(proof);
            } catch (err) {
              spinner.style.display = 'none';
              console.log(err);
              showError();
            }
          } else {
            // Only spinner, no QR, wait for data fetch
            try {
              const fetchPromise = window.dataPromise;
              // wait 500ms in parallel with fetch
              await Promise.all([
                fetchPromise,
                new Promise(resolve => setTimeout(resolve, 500))
              ]);
              draw();
              isReloading = false;
              spinner.style.display = 'none';
              overlay.style.display = 'none';
            } catch (err) {
              spinner.style.display = 'none';
              overlay.style.display = 'none';
              console.log(err);
              showError();
            }
          }
        }
      });

      window.addEventListener('resize', () => {
        if (data) draw();
      });

      const infoButton = document.getElementById('infoButton');
      const infoOverlay = document.getElementById('infoOverlay');
      const gridbox = document.getElementById('gridbox');

      if (infoButton && infoOverlay && gridbox) {
        // open (stop propagation so document click won't immediately close it)
        infoButton.addEventListener('click', e => {
          e.stopPropagation();
          overlay.style.display = 'block';
          const side = gridbox.offsetWidth * 0.92;
          infoOverlay.style.width = side + 'px';
          infoOverlay.style.height = side + 'px';
          infoOverlay.style.display = 'block';
        });

        // close when clicking anywhere on the page except links inside the info box or the info button itself
        document.addEventListener('click', e => {
          if (infoOverlay.style.display !== 'block') return;
          if (e.target.closest('#infoOverlay a')) return;    // allow links
          if (e.target.closest('#infoButton')) return;        // clicking the i should not close
          overlay.style.display = 'none';
          infoOverlay.style.display = 'none';
        });
        window.addEventListener('resize', () => {
          if (infoOverlay.style.display === 'block') {
            const side = gridbox.offsetWidth * 0.92;
            infoOverlay.style.width = side + 'px';
            infoOverlay.style.height = side + 'px';
          }
        });
      }
      
      document.querySelectorAll('#infoOverlay a').forEach(a => {
        a.addEventListener('click', e => e.stopPropagation());
      });

      spinner.style.display = 'block';
      fetchData().finally(() => { 
        spinner.style.display = 'none';
        draw();
      });

    })();
    </script>
  </body>
</html>
